# End-to-End RAG: From Graphs to Production

## What you'll learn

### Define Retrieval-Augmented Generation (RAG) as a graph
Learn to express RAG as a dynamic stateful graph. We'll explore how LangGraph enables modular, debuggable, and production-scalable RAG workflows. **NEW**: Compare multiple graph architectures (Simple, Multi-Query, Ensemble, and Hybrid) to understand how different retrieval strategies impact performance and results.

### Build a working, graph-powered RAG API with performance observability
You'll implement the full loop: embedding and chunking PDFs, storing them in Qdrant, defining multiple retriever-generator graphs with LangChain and LangGraph, and exposing them through a FastAPI interface. **NEW**: Integrate comprehensive performance metrics including timing, cost tracking, and retrieval analytics to understand real-world trade-offs.

### Compare and optimize different RAG approaches
**NEW**: Hands-on experience with four distinct graph types:
- **Simple Graph**: Baseline semantic similarity retrieval
- **Multi-Query Graph**: Query expansion for improved recall
- **Ensemble Graph**: Semantic + keyword retrieval fusion
- **Hybrid Graph**: Semantic retrieval with intelligent reranking

### Go from prototype to production-ready architecture
Understand how graph-based RAG design translates into real-world reliability and maintainability â€” where observability, iteration, and scaling are built in. **NEW**: Learn production monitoring through detailed performance metrics, cost optimization strategies, and comparative analysis tools.
